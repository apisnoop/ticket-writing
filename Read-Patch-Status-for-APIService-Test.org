# -*- ii: apisnoop; -*-
#+TITLE: Read Patch Status for APIService Test
#+AUTHOR: Stephen Heywood
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export
#+PROPERTY: header-args:sql-mode :product postgres

* TODO Progress [1/6]                                                :export:
- [X] APISnoop org-flow : [[https://github.com/apisnoop/ticket-writing/blob/master/Read-Patch-Status-for-APIService-Test.org][Read-Patch-Status-for-APIService-Test.org]]
- [ ] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining APIService endpoints which are untested.

With this query you can filter untested endpoints by their category and eligiblity for conformance.
e.g below shows a query to find all conformance eligible untested,stable,core endpoints

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      endpoint,
      -- k8s_action,
      path,
      -- description,
      kind
      FROM testing.untested_stable_endpoint
      where eligible is true
      -- and category = 'core'
      and endpoint ilike '%APIServiceStatus'
      order by kind, endpoint desc
      limit 5;
  #+end_src

  #+RESULTS: untested_stable_core_endpoints
  #+begin_SRC example
                   endpoint                 |                           path                            |    kind
  ------------------------------------------+-----------------------------------------------------------+------------
   replaceApiregistrationV1APIServiceStatus | /apis/apiregistration.k8s.io/v1/apiservices/{name}/status | APIService
   readApiregistrationV1APIServiceStatus    | /apis/apiregistration.k8s.io/v1/apiservices/{name}/status | APIService
   patchApiregistrationV1APIServiceStatus   | /apis/apiregistration.k8s.io/v1/apiservices/{name}/status | APIService
  (3 rows)

  #+end_SRC


* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline
1. Create a REST Client

2. Get JSON response for the v1.networking.k8s.io APIService 'status' endpoint

3. Confirm that no error during GET request

4. TBD: Validate the response?

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
     package main

     import (
       // "encoding/json"
       "context"
       "flag"
       "fmt"
       "os"
       // v1 "k8s.io/api/core/v1"
       // "k8s.io/client-go/dynamic"
       // "k8s.io/apimachinery/pkg/runtime/schema"
       // metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
       "k8s.io/client-go/kubernetes"
       // "k8s.io/apimachinery/pkg/types"
       "k8s.io/client-go/tools/clientcmd"
     )

     // helper function that mirrors framework.ExpectNoError
     func ExpectNoError(err error, msg string) {
       if err != nil {
         errMsg := msg + fmt.Sprintf(" %v\n", err)
         os.Stderr.WriteString(errMsg)
         os.Exit(1)
       }
     }

     // helper function that mirrors framework.ExpectEqual
     func ExpectEqual(a int, b int, msg string, i interface{}) {
       if a != b {
         errMsg := msg + fmt.Sprintf(" %v\n", i)
         os.Stderr.WriteString(errMsg)
         os.Exit(1)
       }
     }

     // helper function to inspect various interfaces
     func inspect(level int, name string, i interface{}) {
       fmt.Printf("Inspecting: %s\n", name)
       fmt.Printf("Inspect level: %d   Type: %T\n", level, i)
       switch level {
       case 1:
         fmt.Printf("%+v\n\n", i)
       case 2:
         fmt.Printf("%#v\n\n", i)
       default:
         fmt.Printf("%v\n\n", i)
       }
     }

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       if err != nil {
         fmt.Println(err, "Could not build config from flags")
         return
       }
       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
       ClientSet, _ := kubernetes.NewForConfig(config)
       // DynamicClientSet, _ := dynamic.NewForConfig(config)
       // podResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}

       // TEST BEGINS HERE

       fmt.Println("[status] starting test...")

       restClient := ClientSet.Discovery().RESTClient()
       _ , err = restClient.Get().AbsPath("/apis/apiregistration.k8s.io/v1/apiservices/v1.networking.k8s.io/status").SetHeader("Accept", "application/json").DoRaw(context.TODO())
       ExpectNoError(err, "Could not get ../apiservices/v1.networking.k8s.io/status.")


       // TEST ENDS HERE

       fmt.Println("[status] complete")

     }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   [status] starting test...
   [status] complete
   #+end_src

* Verifying increase in coverage with APISnoop                       :export:

** Reset stats

#+begin_src sql-mode :eval never-export :exports both :session none
delete from testing.audit_event;
#+end_src

#+RESULTS:
#+begin_SRC example
DELETE 11000
#+end_SRC

** Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent
      from testing.audit_event
      where useragent like 'live%';
  #+end_src

  #+RESULTS:
  #+begin_SRC example
       useragent
  -------------------
   live-test-writing
  (1 row)

  #+end_SRC

** List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from testing.endpoint_hit_by_new_test;
#+end_src

#+RESULTS:
#+begin_SRC example
     useragent     |               endpoint                | hit_by_ete | hit_by_new_test
-------------------+---------------------------------------+------------+-----------------
 live-test-writing | readApiregistrationV1APIServiceStatus | f          |               6
(1 row)

#+end_SRC

** Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from testing.projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             862 |          343 |          344 |                1
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, *test coverage will go up by 1 points*

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance


* scratch
#+BEGIN_SRC
CREATE OR REPLACE VIEW "public"."untested_stable_endpoints" AS
  SELECT
    ec.*,
    ao.description,
    ao.http_method
    FROM endpoint_coverage ec
           JOIN
           api_operation_material ao ON (ec.bucket = ao.bucket AND ec.job = ao.job AND ec.operation_id = ao.operation_id)
   WHERE ec.level = 'stable'
     AND tested is false
     AND ao.deprecated IS false
     AND ec.job != 'live'
   ORDER BY hit desc
            ;
#+END_SRC


* check e2e test run

#+begin_src sql-mode
  select distinct endpoint
    from audit_event
   where test like '%Sample API Server using the current Aggregator%'
     and endpoint like '%APIService%'                                                                
   order by endpoint;

#+end_src

#+RESULTS:
#+begin_SRC example
             endpoint
-----------------------------------
 createApiregistrationV1APIService
 deleteApiregistrationV1APIService
 readApiregistrationV1APIService
(3 rows)

#+end_SRC
