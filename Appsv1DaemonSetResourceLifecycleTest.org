# -*- ii: apisnoop; -*-
#+TITLE: AppsV1DaemonSet resource lifecycle test+promote - +5
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export
#+PROPERTY: header-args:sql-mode :product postgres


* Identifying an untested feature Using APISnoop :export:

According to this APIsnoop query, there are still some remaining DaemonSet endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      endpoint,
      path,
      kind
      FROM testing.untested_stable_endpoint
      where eligible is true
      and kind like 'DaemonSet'
      order by kind, endpoint desc
      limit 10;
  #+end_src

  #+RESULTS: untested_stable_core_endpoints
  #+begin_SRC example
                   endpoint                  |                             path                              |   kind
  -------------------------------------------+---------------------------------------------------------------+-----------
   replaceAppsV1NamespacedDaemonSetStatus    | /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status | DaemonSet
   readAppsV1NamespacedDaemonSetStatus       | /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status | DaemonSet
   patchAppsV1NamespacedDaemonSetStatus      | /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status | DaemonSet
   listAppsV1DaemonSetForAllNamespaces       | /apis/apps/v1/daemonsets                                      | DaemonSet
   deleteAppsV1CollectionNamespacedDaemonSet | /apis/apps/v1/namespaces/{namespace}/daemonsets               | DaemonSet
  (5 rows)

  #+end_SRC


* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/apps/v1/daemonset.go][client-go - DaemonSet]]

* The mock test                                                      :export:
** Test outline
1. Create a DaemonSet with a static label

2. Patch the DaemonSet with a new Label and updated data

3. Get the DaemonSet to ensure it's patched

4. Update the DaemonSet

5. List all DaemonSets in all Namespaces
   find the DaemonSet(1)
   ensure that the DaemonSet is found and is updated

6. Delete Namespaced DaemonSet(1) via a Collection with a LabelSelector

** Test the functionality in Go
   #+begin_src go
     package main

     import (
       "context"
       "encoding/json"
       "flag"
       "fmt"
       "time"
       "os/exec"

       utilrand "k8s.io/apimachinery/pkg/util/rand"

       "k8s.io/client-go/tools/cache"

       appsv1 "k8s.io/api/apps/v1"
       v1 "k8s.io/api/core/v1"
       "os"
       // "k8s.io/client-go/dynamic"
       // "k8s.io/apimachinery/pkg/runtime/schema"
       metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
       "k8s.io/apimachinery/pkg/types"
       watch "k8s.io/apimachinery/pkg/watch"
       "k8s.io/client-go/kubernetes"
       "k8s.io/client-go/tools/clientcmd"
       watchtools "k8s.io/client-go/tools/watch"
     )

     const (
       dsReadyTimeout = 20 * time.Second
     )

     // helper function that is close to framework.ExpectNoError
     func ExpectNoError(err error, msg string, i interface{}) {
       if err != nil {
         errMsg := msg + fmt.Sprintf(" %v\n", i)
         os.Stderr.WriteString(errMsg)
         os.Exit(1)
       }
     }

     // logging time and cluster resources at different stages of the test
     func logTimeKubectl() {
       fmt.Println("===============")
       t, _ := exec.Command("date", "+%H:%M:%S.%3N").Output()
       log, _ := exec.Command("kubectl", "-n", "default", "get", "all", "-owide").Output()
       fmt.Printf("%s\n", t)
       fmt.Printf("%s\n", log)
       fmt.Println("===============")
     }

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       ExpectNoError(err, "Unable to create a client", err)

       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
       ClientSet, _ := kubernetes.NewForConfig(config)
       // DynamicClientSet, _ := dynamic.NewForConfig(config)
       // podResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}

       // TEST BEGINS HERE

       ns := "default"
       testDaemonSetName := "test-ds-" + utilrand.String(5)
       testDaemonSetImageInitial := "nginx"
       testDaemonSetImagePatch := "alpine"
       testDaemonSetImageUpdate := "httpd"
       testDaemonSetStaticLabel := map[string]string{"test-static": "true"}
       testDaemonSetStaticLabelFlat := "test-static=true"
       testDaemonSetSelector := map[string]string{"app": testDaemonSetName}
       testNamespaceName := "default"

       w := &cache.ListWatch{
         WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
           options.LabelSelector = testDaemonSetStaticLabelFlat
           return ClientSet.AppsV1().DaemonSets(ns).Watch(context.TODO(), options)
         },
       }

       dsList, err := ClientSet.AppsV1().DaemonSets("").List(context.TODO(), metav1.ListOptions{LabelSelector: testDaemonSetStaticLabelFlat})
       ExpectNoError(err, "failed to list DaemonSets", err)
       logTimeKubectl()

       fmt.Println("creating a DaemonSet")
       testDaemonSet := appsv1.DaemonSet{
         ObjectMeta: metav1.ObjectMeta{
           Name:   testDaemonSetName,
           Labels: testDaemonSetStaticLabel,
         },
         Spec: appsv1.DaemonSetSpec{
           Selector: &metav1.LabelSelector{
             MatchLabels: testDaemonSetSelector,
           },
           Template: v1.PodTemplateSpec{
             ObjectMeta: metav1.ObjectMeta{
               Labels: testDaemonSetSelector,
             },
             Spec: v1.PodSpec{
               Containers: []v1.Container{{
                 Name:  testDaemonSetName,
                 Image: testDaemonSetImageInitial,
               }},
             },
           },
         },
       }
       _, err = ClientSet.AppsV1().DaemonSets(testNamespaceName).Create(context.TODO(), &testDaemonSet, metav1.CreateOptions{})
       ExpectNoError(err, "failed to create the DaemonSet. %v", err)

       fmt.Println("watching for the DaemonSet to be added")
       ctx, cancel := context.WithTimeout(context.Background(), dsReadyTimeout)
       defer cancel()
       _, err = watchtools.Until(ctx, dsList.ResourceVersion, w, func(event watch.Event) (bool, error) {
         if ds, ok := event.Object.(*appsv1.DaemonSet); ok {
           found := ds.ObjectMeta.Name == testDaemonSet.ObjectMeta.Name &&
             ds.ObjectMeta.Namespace == ns &&
             ds.Status.NumberReady == ds.Status.DesiredNumberScheduled &&
             ds.ObjectMeta.Labels["test-static"] == "true"
           if !found {
             fmt.Printf("observed DaemonSet %v in namespace %v with labels: %v\n", ds.ObjectMeta.Name, ds.ObjectMeta.Namespace, ds.ObjectMeta.Labels)
             return false, nil
           }
           fmt.Printf("Found DaemonSet %v in namespace %v with labels: %#v \n", ds.ObjectMeta.Name, ds.ObjectMeta.Namespace, ds.ObjectMeta.Labels)
           fmt.Printf("Status: %#v \n", ds.Status)
           return found, nil
         }
         fmt.Printf("Observed event: %+v\n", event.Object)
         return false, nil
       })
       // ExpectNoError(err, "failed to locate DaemonSet %v in namespace %v", testDaemonSet.ObjectMeta.Name, ns)
       ExpectNoError(err, "failed to locate DaemonSet %v in namespace default", testDaemonSet.ObjectMeta.Name)
       fmt.Printf("DaemonSet %s created\n", testDaemonSetName)

       logTimeKubectl()

       fmt.Println("patching the DaemonSet")
       resourcePatch, err := json.Marshal(map[string]interface{}{
         "metadata": map[string]interface{}{
           "labels": map[string]string{"test-resource": "patched"},
         },
         "spec": map[string]interface{}{
           "template": map[string]interface{}{
             "spec": map[string]interface{}{
               "containers": []map[string]interface{}{{
                 "name":    testDaemonSetName,
                 "image":   testDaemonSetImagePatch,
                 "command": []string{"/bin/sleep", "100000"},
               }},
             },
           },
         },
       })

       ExpectNoError(err, "failed to marshal resource patch. %v", err)
       _, err = ClientSet.AppsV1().DaemonSets(testNamespaceName).Patch(context.TODO(), testDaemonSetName, types.StrategicMergePatchType, []byte(resourcePatch), metav1.PatchOptions{})
       ExpectNoError(err, "failed to patch resource. %v", err)

       logTimeKubectl()

       fmt.Println("watching for the DaemonSet to be patched")
       ctx, cancel = context.WithTimeout(context.Background(), dsReadyTimeout)
       defer cancel()
       _, err = watchtools.Until(ctx, dsList.ResourceVersion, w, func(event watch.Event) (bool, error) {
         switch event.Type {
         case watch.Modified:
           if ds, ok := event.Object.(*appsv1.DaemonSet); ok {
             found := ds.ObjectMeta.Name == testDaemonSet.ObjectMeta.Name &&
               ds.ObjectMeta.Namespace == ns &&
               ds.ObjectMeta.Labels["test-resource"] == "patched"
             if !found {
               fmt.Printf("observed DaemonSet %v in namespace %v with labels: %v \n", ds.ObjectMeta.Name, ds.ObjectMeta.Namespace, ds.ObjectMeta.Labels)
               return false, nil
             }
             fmt.Printf("Found DaemonSet %v in namespace %v with labels: %v \n", ds.ObjectMeta.Name, ds.ObjectMeta.Namespace, ds.ObjectMeta.Labels)
             return found, nil
           }
         default:
           fmt.Printf("Observed event: %+v \n", event.Type)
         }
         return false, nil
       })
       ExpectNoError(err, "failed to delete DaemonSet %v in namespace default", testDaemonSet.ObjectMeta.Name)
       fmt.Printf("DaemonSet %s patched\n", testDaemonSetName)
       logTimeKubectl()

       fmt.Println("fetching the DaemonSet")
       ds, err := ClientSet.AppsV1().DaemonSets(testNamespaceName).Get(context.TODO(), testDaemonSetName, metav1.GetOptions{})
       ExpectNoError(err, "failed to fetch resource. %v", err)

       if ds.ObjectMeta.Labels["test-resource"] != "patched" {
         fmt.Println("failed to patch resource - missing patched label")
         return
       }
       if ds.Spec.Template.Spec.Containers[0].Image != testDaemonSetImagePatch {
         fmt.Println("failed to patch resource - missing patched image")
         return
       }
       if ds.Spec.Template.Spec.Containers[0].Command[0] != "/bin/sleep" {
         fmt.Println("failed to patch resource - missing patched command")
         return
       }

       fmt.Println("updating the DaemonSet")
       dsUpdate := ds
       dsUpdate.ObjectMeta.Labels["test-resource"] = "updated"
       dsUpdate.Spec.Template.Spec.Containers[0].Image = testDaemonSetImageUpdate
       dsUpdate.Spec.Template.Spec.Containers[0].Command = []string{}
       _, err = ClientSet.AppsV1().DaemonSets(testNamespaceName).Update(context.TODO(), dsUpdate, metav1.UpdateOptions{})
       ExpectNoError(err, "failed to update resource. %v", err)

       fmt.Println("listing DaemonSets")
       dss, err := ClientSet.AppsV1().DaemonSets("").List(context.TODO(), metav1.ListOptions{LabelSelector: testDaemonSetStaticLabelFlat})
       ExpectNoError(err, "failed to list DaemonSets. %v", err)

       if len(dss.Items) == 0 {
         fmt.Println("there are no DaemonSets found")
         return
       }
       for _, ds := range dss.Items {
         if ds.ObjectMeta.Labels["test-resource"] != "updated" {
           fmt.Println("failed to patch resource - missing updated label")
           return
         }
         if ds.Spec.Template.Spec.Containers[0].Image != testDaemonSetImageUpdate {
           fmt.Println("failed to patch resource - missing updated image")
           return
         }
         if len(ds.Spec.Template.Spec.Containers[0].Command) != 0 {
           fmt.Println("failed to patch resource - missing updated command")
           return
         }
       }

       logTimeKubectl()

       fmt.Println("deleting the DaemonSet")
       err = ClientSet.AppsV1().DaemonSets(testNamespaceName).DeleteCollection(context.TODO(), metav1.DeleteOptions{}, metav1.ListOptions{LabelSelector: testDaemonSetStaticLabelFlat})
       ExpectNoError(err, "failed to delete the DaemonSet. %v", err)

       fmt.Println("watching for the DaemonSet to be deleted")
       ctx, cancel = context.WithTimeout(context.Background(), dsReadyTimeout)
       defer cancel()
       _, err = watchtools.Until(ctx, dsList.ResourceVersion, w, func(event watch.Event) (bool, error) {
         switch event.Type {
         case watch.Deleted:
           if ds, ok := event.Object.(*appsv1.DaemonSet); ok {
             found := ds.ObjectMeta.Name == testDaemonSet.ObjectMeta.Name &&
               ds.ObjectMeta.Namespace == ns &&
               ds.ObjectMeta.Labels["test-static"] == "true"
             if !found {
               fmt.Printf("observed DaemonSet %v in namespace %v with labels: %v \n", ds.ObjectMeta.Name, ds.ObjectMeta.Namespace, ds.ObjectMeta.Labels)
               return false, nil
             }
             fmt.Printf("Found DaemonSet %v in namespace %v with labels: %v \n", ds.ObjectMeta.Name, ds.ObjectMeta.Namespace, ds.ObjectMeta.Labels)
             return found, nil
           }
         default:
           fmt.Printf("Observed event: %+v \n", event.Type)
         }
         return false, nil
       })
       ExpectNoError(err, "failed to delete DaemonSet %v in namespace default", testDaemonSet.ObjectMeta.Name)
       fmt.Printf("DaemonSet %s deleted\n", testDaemonSetName)

       // TEST ENDS HERE
       fmt.Println("[status] complete")

     }
   #+end_src

   #+RESULTS:
   #+begin_SRC example
   ===============
   12:32:35.532

   NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE     SELECTOR
   service/csi-packet-pd   ClusterIP   10.110.201.122   <none>        12345/TCP   4h27m   app=csi-packet-pd
   service/kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP     4h27m   <none>

   ===============
   creating a DaemonSet
   watching for the DaemonSet to be added
   Found DaemonSet test-ds-8gz6z in namespace default with labels: map[string]string{"test-static":"true"}
   Status: v1.DaemonSetStatus{CurrentNumberScheduled:0, NumberMisscheduled:0, DesiredNumberScheduled:0, NumberReady:0, ObservedGeneration:0, UpdatedNumberScheduled:0, NumberAvailable:0, NumberUnavailable:0, CollisionCount:(*int32)(nil), Conditions:[]v1.DaemonSetCondition(nil)}
   DaemonSet test-ds-8gz6z created
   ===============
   12:32:35.655

   NAME                      READY   STATUS              RESTARTS   AGE   IP       NODE                      NOMINATED NODE   READINESS GATES
   pod/test-ds-8gz6z-z6swc   0/1     ContainerCreating   0          0s    <none>   e2e-control-plane-kmm5q   <none>           <none>

   NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE     SELECTOR
   service/csi-packet-pd   ClusterIP   10.110.201.122   <none>        12345/TCP   4h27m   app=csi-packet-pd
   service/kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP     4h27m   <none>

   NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE   CONTAINERS      IMAGES   SELECTOR
   daemonset.apps/test-ds-8gz6z   1         1         0       1            0           <none>          0s    test-ds-8gz6z   nginx    app=test-ds-8gz6z

   ===============
   patching the DaemonSet
   ===============
   12:32:35.766

   NAME                      READY   STATUS        RESTARTS   AGE   IP       NODE                      NOMINATED NODE   READINESS GATES
   pod/test-ds-8gz6z-z6swc   0/1     Terminating   0          0s    <none>   e2e-control-plane-kmm5q   <none>           <none>

   NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE     SELECTOR
   service/csi-packet-pd   ClusterIP   10.110.201.122   <none>        12345/TCP   4h27m   app=csi-packet-pd
   service/kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP     4h27m   <none>

   NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE   CONTAINERS      IMAGES   SELECTOR
   daemonset.apps/test-ds-8gz6z   1         1         0       0            0           <none>          0s    test-ds-8gz6z   alpine   app=test-ds-8gz6z

   ===============
   watching for the DaemonSet to be patched
   Observed event: ADDED
   observed DaemonSet test-ds-8gz6z in namespace default with labels: map[test-static:true]
   Found DaemonSet test-ds-8gz6z in namespace default with labels: map[test-resource:patched test-static:true]
   DaemonSet test-ds-8gz6z patched
   ===============
   12:32:35.849

   NAME                      READY   STATUS        RESTARTS   AGE   IP       NODE                      NOMINATED NODE   READINESS GATES
   pod/test-ds-8gz6z-z6swc   0/1     Terminating   0          0s    <none>   e2e-control-plane-kmm5q   <none>           <none>

   NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE     SELECTOR
   service/csi-packet-pd   ClusterIP   10.110.201.122   <none>        12345/TCP   4h27m   app=csi-packet-pd
   service/kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP     4h27m   <none>

   NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE   CONTAINERS      IMAGES   SELECTOR
   daemonset.apps/test-ds-8gz6z   1         1         0       0            0           <none>          0s    test-ds-8gz6z   alpine   app=test-ds-8gz6z

   ===============
   fetching the DaemonSet
   updating the DaemonSet
   listing DaemonSets
   ===============
   12:32:35.917

   NAME                      READY   STATUS        RESTARTS   AGE   IP       NODE                      NOMINATED NODE   READINESS GATES
   pod/test-ds-8gz6z-z6swc   0/1     Terminating   0          0s    <none>   e2e-control-plane-kmm5q   <none>           <none>

   NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE     SELECTOR
   service/csi-packet-pd   ClusterIP   10.110.201.122   <none>        12345/TCP   4h27m   app=csi-packet-pd
   service/kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP     4h27m   <none>

   NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE   CONTAINERS      IMAGES   SELECTOR
   daemonset.apps/test-ds-8gz6z   1         1         0       0            0           <none>          0s    test-ds-8gz6z   httpd    app=test-ds-8gz6z

   ===============
   deleting the DaemonSet
   watching for the DaemonSet to be deleted
   Observed event: ADDED
   Observed event: MODIFIED
   Observed event: MODIFIED
   Observed event: MODIFIED
   Observed event: MODIFIED
   Observed event: MODIFIED
   Found DaemonSet test-ds-8gz6z in namespace default with labels: map[test-resource:updated test-static:true]
   DaemonSet test-ds-8gz6z deleted
   [status] complete
   #+end_SRC

* Verifying increase it coverage with APISnoop :export:
** Discover useragents:

#+begin_src sql-mode :eval never-export :exports both :session none
  select distinct useragent from audit_event
   where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
#+end_src

** List endpoints hit by the test:

#+begin_src sql-mode :exports both :session none
select * from testing.endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

** Display endpoint coverage change:

#+begin_src sql-mode :eval never-export :exports both :session none
  select * from testing.projected_change_in_coverage;
#+end_src

#+RESULTS:
#+begin_SRC example
   category    | total_endpoints | old_coverage | new_coverage | change_in_number
---------------+-----------------+--------------+--------------+------------------
 test_coverage |             873 |          357 |          359 |                2
(1 row)

#+end_SRC


* Final notes :export:
If a test with these calls gets merged, **test coverage will go up by 5 points**

This test is also created with the goal of conformance promotion.

-----  
/sig testing  

/sig architecture  

/area conformance  

* Options :neverexport:
** Delete all events after postgres initialization
   #+begin_src sql-mode :eval never-export :exports both :session none
   delete from audit_event where bucket = 'apisnoop' and job='live';
   #+end_src

* Open Tasks
  Set any open tasks here, using org-todo
** DONE Live Your Best Life
* Footnotes                                                     :neverexport:
  :PROPERTIES:
  :CUSTOM_ID: footnotes
  :END:
