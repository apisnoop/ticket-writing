# -*- ii: apisnoop; -*-
#+TITLE: Deployment Apps endpoints
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export
#+PROPERTY: header-args:sql-mode :product postgres

* TODO Progress [2/5]                                                :export:
- [X] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/][MyEndpoint.org]]
- [X] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

with this query you can filter untested endpoints by their category and eligiblity for conformance.
e.g below shows a query to find all conformance eligible untested,stable,core endpoints

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      endpoint,
      -- k8s_action,
      -- path,
      -- description,
      kind
      FROM testing.untested_stable_endpoint
      where eligible is true
        and endpoint like '%Deployment%'
      --and category = 'core'
      order by kind, endpoint desc
      limit 25;
  #+end_src

  #+RESULTS: untested_stable_core_endpoints
  #+begin_SRC example
                  endpoint                 |    kind
  -----------------------------------------+------------
   replaceAppsV1NamespacedDeploymentStatus | Deployment
   replaceAppsV1NamespacedDeploymentScale  | Scale
   readAppsV1NamespacedDeploymentScale     | Scale
   patchAppsV1NamespacedDeploymentScale    | Scale
  (4 rows)

  #+end_SRC






* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

- [[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#updating-resources][kubeclt scale / updating resources]]
- [[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#scale][Scale]]
- [[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#patch][kubectl-commands#patch]]
- [[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#replace][kubectl-commands#replace]]
- [[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment][Scaling a deployment Kubectl commands]]
* The mock test                                                      :export:
** Test outline



*** 1. Create a deployment yaml file, namespace and Deployment

#+begin_src yaml :tangle deployment_test.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
#+end_src

- Tangle to create the .yaml file - `,bt`


- See if the yaml file was created
#+begin_src shell :results raw
  pwd
 ls -al /home/riaan/Project/ticket-writing |grep .yaml

 #ls -al /home/ii/ticket-writing | grep yaml
#+end_src

#+RESULTS:
#+begin_example
/home/riaan/Project/ticket-writing
-rw-rw-r--  1 riaan riaan    404 Dec 11 06:39 deployment_test.yaml
-rw-rw-r--  1 riaan riaan    455 Dec 11 10:28 replicaset_test.yaml
-rw-rw-r--  1 riaan riaan   1029 Dec 11 06:39 statefulset_test.yaml
#+end_example





- Create a Namespace
#+begin_src shell :results raw
kubectl create namespace app-deploy-tests
#+end_src

#+RESULTS:
#+begin_example
namespace/app-deploy-tests created
#+end_example


- Create a Deployment
#+begin_src shell :results raw
kubectl apply -f deployment_test.yaml --namespace=app-deploy-tests
#+end_src

#+RESULTS:
#+begin_example
deployment.apps/nginx-deployment created
#+end_example



***  2. Find the deployment
#+begin_src shell :results raw
  kubectl get deployments -A | grep app
#+end_src

#+RESULTS:
#+begin_example
app-deploy-tests     nginx-deployment         3/3     3            3           87s
#+end_example




*** 3. Scale the Deployment

#+begin_src shell :results raw
  kubectl scale deployment.v1.apps/nginx-deployment -n app-deploy-tests --replicas=4
  sleep 5
  kubectl get deployments -A | grep app
  kubectl rollout status deployment.v1.apps/nginx-deployment -n app-deploy-tests
#+end_src

#+RESULTS:
#+begin_example
deployment.apps/nginx-deployment scaled
app-deploy-tests     nginx-deployment         4/4     4            4           103s
deployment "nginx-deployment" successfully rolled out
#+end_example





*** 4. Update the deployment:
#+begin_src shell :results raw
kubectl set image deployment.v1.apps/nginx-deployment -n app-deploy-tests nginx=nginx:1.16.0 --record
#+end_src

#+RESULTS:
#+begin_example
#+end_example






- and update it agaian, because we can...

#+begin_src shell :results raw
kubectl set image deployment.v1.apps/nginx-deployment -n app-deploy-tests nginx=nginx:1.16.1 --record
#+end_src

#+RESULTS:
#+begin_example
deployment.apps/nginx-deployment image updated
#+end_example




*** 5. Describe the deployments to see if it was updated with history
#+begin_src shell :results raw
  kubectl describe deployments -n app-deploy-tests | grep image
  kubectl rollout history deployment.v1.apps/nginx-deployment -n app-deploy-tests
#+end_src

#+RESULTS:
#+begin_example
                          kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --namespace=app-deploy-tests --record=true
deployment.apps/nginx-deployment
REVISION  CHANGE-CAUSE
1         <none>
2         kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.0 --namespace=app-deploy-tests --record=true
3         kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --namespace=app-deploy-tests --record=true

#+end_example




*** 6. Describe the status of the deployment
#+begin_src shell :results raw
kubectl rollout status deployment.v1.apps/nginx-deployment -n app-deploy-tests
#+end_src




*** 7. The following kubectl command sets the spec with progressDeadlineSeconds to make the controller report lack of progress for a Deployment after 1 minute:

#+begin_src shell :results raw
  #This command fail!
  (

      kubectl patch deployment.v1.apps/nginx-deployment -p -n app-deploy-tests '{"spec":{"progressDeadlineSeconds":60}}'


  ) 2>&1
  :
#+end_src

#+RESULTS:
#+begin_example
error: there is no need to specify a resource type as a separate argument when passing arguments in resource/name form (e.g. 'kubectl get resource/<resource_name>' instead of 'kubectl get resource resource/<resource_name>'
#+end_example




*** 8. Cleanup


- Delete the deployment and the namespace
#+begin_src shell :results raw
  kubectl delete deploy/deployment.v1.apps/nginx-deployment
  kubectl delete namespaces/app-deploy-tests

#+end_src

#+RESULTS:
#+begin_example
namespace "app-deploy-tests" deleted
#+end_example



- Look for deployment and namespace to check if it is deleted

#+begin_src shell :results raw
  kubectl get namespace app-deploy-tests
  kubectl get deployment nginx-deployment
#+end_src


- ALL DONE!



*** Delete audit events to check for success

- Count all audit events
#+begin_src sql-mode
select count(*) from testing.audit_event;
#+end_src

#+RESULTS:
#+begin_SRC example
 count
-------
  1705
(1 row)

#+end_SRC



- Delete all audit events
#+begin_src sql-mode
delete from testing.audit_event;
#+end_src

#+RESULTS:
#+begin_SRC example
DELETE 695
#+end_SRC




*** Test to see is new endpoint was hit by the test
#+begin_src sql-mode :eval never-export :exports both :session none
  select distinct  endpoint, useragent
                   -- to_char(to_timestamp(release_date::bigint), ' HH:MI') as time
  from testing.audit_event
  where endpoint ilike '%Deployment%'
    -- and release_date::BIGINT > round(((EXTRACT(EPOCH FROM NOW()))::numeric)*1000,0) - 60000
  and useragent like 'kubectl%'
  order by endpoint
  limit 100;

#+end_src

#+RESULTS:
#+begin_SRC example
               endpoint               |                    useragent
--------------------------------------+--------------------------------------------------
 createAppsV1NamespacedDeployment     | kubectl/v1.19.4 (linux/amd64) kubernetes/d360454
 listAppsV1DeploymentForAllNamespaces | kubectl/v1.19.4 (linux/amd64) kubernetes/d360454
 listAppsV1NamespacedDeployment       | kubectl/v1.19.4 (linux/amd64) kubernetes/d360454
 patchAppsV1NamespacedDeployment      | kubectl/v1.19.4 (linux/amd64) kubernetes/d360454
 patchAppsV1NamespacedDeploymentScale | kubectl/v1.19.4 (linux/amd64) kubernetes/d360454
 readAppsV1NamespacedDeployment       | kubectl/v1.19.4 (linux/amd64) kubernetes/d360454
(6 rows)

#+end_SRC

*** About Scale enpoints

- The file [[https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/kubernetes/typed/apps/v1/deployment.go#L186-L228][deployment.go]] have three code sections that deal with scale endpoint replace-, read- and patchAppsV1NamespacedDeploymentScale.
  However neither of these tests blocks touch the endpoint

  The [[https://github.com/kubernetes/kubernetes/blob/master/test/e2e/apps/statefulset.go#L848-L872][statefulsets.go]] file contain test similar scale endpoint for relace and read which make these endpoint conformance tested.

  If the statefulsets file could be used as a temple it could be applied to the deployment endpoint. The Patch --Deploymentscale endpoint was touch with a simple kubeclt command
  The same logic could then be applied to the Patch -- statefulsetsScale endpoint in another test.

**Patch**
 StatefulSet
 HTTP Request
 PATCH /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}

 Deployment
 HTTP Request
 PATCH /apis/apps/v1/namespaces/{namespace}/deployments/{name}

 Patch for both statefulsets and deployments use the same HTTP Request logic


** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
     package main

     import (
       // "encoding/json"
       "fmt"
       "context"
       "flag"
       "os"
       v1 "k8s.io/api/core/v1"
       appsv1 "k8s.io/api/apps/v1"
       "k8s.io/client-go/dynamic"
       "k8s.io/apimachinery/pkg/runtime"
       "k8s.io/apimachinery/pkg/runtime/schema"
       metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	     unstructuredv1 "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
       "k8s.io/client-go/kubernetes"
       "k8s.io/apimachinery/pkg/types"
       "k8s.io/client-go/tools/clientcmd"
     )

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       if err != nil {
           fmt.Println(err, "Could not build config from flags")
           return
       }
       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
      ClientSet, _ := kubernetes.NewForConfig(config)
      DynamicClientSet, _ := dynamic.NewForConfig(config)
      deploymentResource := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "deployments"}


       // TEST BEGINS HERE
  testDeploymentName := "test-deployment"
  testDeploymentInitialImage := "nginx"
  testDeploymentPatchImage := "alpine"
  testDeploymentUpdateImage := "httpd"
  testDeploymentDefaultReplicas := int32(3)
  testDeploymentMinimumReplicas := int32(1)
  testDeploymentNoReplicas := int32(0)
  testDeploymentLabelSelectors := metav1.LabelSelector{
      MatchLabels: map[string]string{"app": "test-deployment"},
  }
  testNamespaceName := "default"

  fmt.Println("creating a Deployment")
  testDeployment := appsv1.Deployment{
      ObjectMeta: metav1.ObjectMeta{
          Name: testDeploymentName,
          Labels: map[string]string{"test-deployment-static": "true"},
      },
      Spec: appsv1.DeploymentSpec{
          Replicas: &testDeploymentDefaultReplicas,
          Selector: &testDeploymentLabelSelectors,
          Template: v1.PodTemplateSpec{
              ObjectMeta: metav1.ObjectMeta{
                  Labels: testDeploymentLabelSelectors.MatchLabels,
              },
              Spec: v1.PodSpec{
                  Containers: []v1.Container{{
                      Name: testDeploymentName,
                      Image: testDeploymentInitialImage,
                  }},
              },
          },
      },
  }
  _, err = ClientSet.AppsV1().Deployments(testNamespaceName).Create(&testDeployment)
  if err != nil {
      fmt.Println(err)
      return
  }

  fmt.Println("watching for the Deployment to be added")
  dplmtWatchTimeoutSeconds := int64(180)
  dplmtWatch, err := ClientSet.AppsV1().Deployments(testNamespaceName).Watch(metav1.ListOptions{LabelSelector: "test-deployment-static=true", TimeoutSeconds: &dplmtWatchTimeoutSeconds})
  if err != nil {
      fmt.Println(err, "Failed to setup watch on newly created Deployment")
      return
  }

  dplmtWatchChan := dplmtWatch.ResultChan()
  for event := range dplmtWatchChan {
      if event.Type == watch.Added {
          break
      }
  }
  defer func() {
    fmt.Println("deleting the Deployment")
    err = ClientSet.AppsV1().Deployments(testNamespaceName).DeleteCollection(&metav1.DeleteOptions{}, metav1.ListOptions{LabelSelector: "test-deployment-static=true"})
    if err != nil {
      fmt.Println(err)
      return
    }
    for event := range dplmtWatchChan {
      deployment, ok := event.Object.(*appsv1.Deployment)
      if ok != true {
        fmt.Println("unable to convert event.Object type")
        return
      }
      if event.Type == watch.Deleted && deployment.ObjectMeta.Name == testDeploymentName {
        break
      }
    }
  }()
  fmt.Println("waiting for all Replicas to be Ready")
  for event := range dplmtWatchChan {
      deployment, ok := event.Object.(*appsv1.Deployment)
      if ok != true {
          fmt.Println("unable to convert event.Object type")
          return
      }
      if deployment.Status.AvailableReplicas == testDeploymentDefaultReplicas &&
         deployment.Status.ReadyReplicas == testDeploymentDefaultReplicas {
          break
      }
  }

  fmt.Println("patching the Deployment")
  deploymentPatch, err := json.Marshal(map[string]interface{}{
      "metadata": map[string]interface{}{
          "labels": map[string]string{"test-deployment": "patched"},
      },
      "spec": map[string]interface{}{
          "replicas": testDeploymentMinimumReplicas,
          "template": map[string]interface{}{
              "spec": map[string]interface{}{
                  "containers": []map[string]interface{}{{
                      "name": testDeploymentName,
                      "image": testDeploymentPatchImage,
                      "command": []string{"/bin/sleep", "100000"},
                  }},
              },
          },
      },
  })
  if err != nil {
      fmt.Println(err, "failed to Marshal Deployment JSON patch")
      return
  }
  _, err = ClientSet.AppsV1().Deployments(testNamespaceName).Patch(testDeploymentName, types.StrategicMergePatchType, []byte(deploymentPatch))
  if err != nil {
       fmt.Println(err, "failed to patch Deployment")
       return
  }

  for event := range dplmtWatchChan {
      if event.Type == watch.Modified {
          break
      }
  }
  fmt.Println("waiting for Replicas to scale")
  for event := range dplmtWatchChan {
      deployment, ok := event.Object.(*appsv1.Deployment)
      if ok != true {
          fmt.Println("unable to convert event.Object type")
          return
      }
      if deployment.Status.AvailableReplicas == testDeploymentMinimumReplicas &&
         deployment.Status.ReadyReplicas == testDeploymentMinimumReplicas {
          break
      }
  }


  fmt.Println("listing Deployments")
  deploymentsList, err := ClientSet.AppsV1().Deployments("").List(metav1.ListOptions{LabelSelector: "test-deployment-static=true"})
  if err != nil {
      fmt.Println(err, "failed to list Deployments")
      return
  }
  foundDeployment := false
  for _, deploymentItem := range deploymentsList.Items {
      if deploymentItem.ObjectMeta.Name == testDeploymentName &&
         deploymentItem.ObjectMeta.Namespace == testNamespaceName &&
         deploymentItem.ObjectMeta.Labels["test-deployment-static"] == "true" &&
         *deploymentItem.Spec.Replicas == testDeploymentMinimumReplicas &&
         deploymentItem.Spec.Template.Spec.Containers[0].Image == testDeploymentPatchImage {
          foundDeployment = true
          break
      }
  }
  if foundDeployment != true {
      fmt.Println("unable to find the Deployment in list")
      return
  }

  fmt.Println("updating the DeploymentStatus")
  testDeploymentUpdate := testDeployment
  testDeploymentUpdate.ObjectMeta.Labels["test-deployment"] = "updated"
  testDeploymentUpdate.Spec.Template.Spec.Containers[0].Image = testDeploymentUpdateImage
  testDeploymentDefaultReplicasPointer := &testDeploymentDefaultReplicas
  testDeploymentUpdate.Spec.Replicas = testDeploymentDefaultReplicasPointer
  testDeploymentUpdate.Status.ReadyReplicas = testDeploymentNoReplicas
  testDeploymentUpdateUnstructuredMap, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&testDeploymentUpdate)
  if err != nil {
      fmt.Println(err, "failed to convert to unstructured")
  }
  testDeploymentUpdateUnstructured := unstructuredv1.Unstructured{
      Object: testDeploymentUpdateUnstructuredMap,
  }
	// currently this hasn't been able to hit the endpoint replaceAppsV1NamespacedDeploymentStatus
  _, err = DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Update(&testDeploymentUpdateUnstructured, metav1.UpdateOptions{})//, "status")
  if err != nil {
      fmt.Println(err, "failed to update the DeploymentStatus")
      return
  }
  for event := range dplmtWatchChan {
      if event.Type == watch.Modified {
          break
      }
  }

  fmt.Println("fetching the DeploymentStatus")
  deploymentGetUnstructured, err := DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Get(testDeploymentName, metav1.GetOptions{}, "status")
  if err != nil {
      fmt.Println(err, "failed to fetch the Deployment")
      return
  }
  deploymentGet := appsv1.Deployment{}
  err = runtime.DefaultUnstructuredConverter.FromUnstructured(deploymentGetUnstructured.Object, &deploymentGet)
  if err != nil {
      fmt.Println(err, "failed to convert the unstructured response to a Deployment")
      return
  }
  if ! (deploymentGet.Spec.Template.Spec.Containers[0].Image == testDeploymentUpdateImage || deploymentGet.Status.ReadyReplicas == testDeploymentNoReplicas || deploymentGet.ObjectMeta.Labels["test-deployment"] == "updated") {
      fmt.Println("failed to update the Deployment (did not return correct values)")
      return
  }
  for event := range dplmtWatchChan {
      if event.Type == watch.Modified {
          break
      }
  }
  for event := range dplmtWatchChan {
      deployment, ok := event.Object.(*appsv1.Deployment)
      if ok != true {
          fmt.Println("failed to convert event Object to a Deployment")
          return
      }
      if deployment.Status.ReadyReplicas == testDeploymentDefaultReplicas {
          break
      }
  }

  fmt.Println("patching the DeploymentStatus")
  deploymentStatusPatch, err := json.Marshal(map[string]interface{}{
      "metadata": map[string]interface{}{
          "labels": map[string]string{"test-deployment": "patched-status"},
      },
      "status": map[string]interface{}{
          "readyReplicas": testDeploymentNoReplicas,
      },
  })
  if err != nil {
      fmt.Println(err, "failed to Marshal Deployment JSON patch")
      return
  }
  DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Patch(testDeploymentName, types.StrategicMergePatchType, []byte(deploymentStatusPatch), metav1.PatchOptions{}, "status")

  fmt.Println("fetching the DeploymentStatus")
  deploymentGetUnstructured, err = DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Get(testDeploymentName, metav1.GetOptions{}, "status")
  if err != nil {
      fmt.Println(err, "failed to fetch the DeploymentStatus")
      return
  }
  deploymentGet = appsv1.Deployment{}
  err = runtime.DefaultUnstructuredConverter.FromUnstructured(deploymentGetUnstructured.Object, &deploymentGet)
  if err != nil {
      fmt.Println(err, "failed to convert the unstructured response to a Deployment")
      return
  }
  if ! (deploymentGet.Spec.Template.Spec.Containers[0].Image == testDeploymentUpdateImage || deploymentGet.Status.ReadyReplicas == 0 || deploymentGet.ObjectMeta.Labels["test-deployment"] == "patched-status") {
      fmt.Println("failed to update the Deployment (did not return correct values)")
      return
  }
  for event := range dplmtWatchChan {
      if event.Type == watch.Modified {
          break
      }
  }
  for event := range dplmtWatchChan {
      deployment, ok := event.Object.(*appsv1.Deployment)
      if ok != true {
          fmt.Println("failed to convert event Object to a Deployment")
          return
      }
      if deployment.Status.ReadyReplicas == testDeploymentDefaultReplicas {
          break
      }
  }

       // TEST ENDS HERE
  fmt.Println("[status] complete")
}



   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   #+end_src



* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent
      from testing.audit_event
      where useragent like 'live%';
  #+end_src

  #+RESULTS:
  :  useragent
  : -----------
  : (0 rows)
  :

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from testing.endpoint_hit_by_new_test;
#+end_src

#+RESULTS:
#+begin_SRC example
 useragent | endpoint | hit_by_ete | hit_by_new_test
-----------+----------+------------+-----------------
(0 rows)

#+end_SRC

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from testing.projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             862 |          343 |          343 |                0
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance


* scratch
#+BEGIN_SRC
CREATE OR REPLACE VIEW "public"."untested_stable_endpoints" AS
  SELECT
    ec.*,
    ao.description,
    ao.http_method
    FROM endpoint_coverage ec
           JOIN
           api_operation_material ao ON (ec.bucket = ao.bucket AND ec.job = ao.job AND ec.operation_id = ao.operation_id)
   WHERE ec.level = 'stable'
     AND tested is false
     AND ao.deprecated IS false
     AND ec.job != 'live'
   ORDER BY hit desc
            ;
#+END_SRC
